""
Indian Airlines IVR - Complete Twilio + OpenAI Integration
Conversational AI Interface Development

This integrates with your EXISTING Twilio account (+19789694592)
"""

from fastapi import FastAPI, Request
from fastapi.responses import Response
from twilio.twiml.voice_response import VoiceResponse, Gather
import uuid
import os
from openai import OpenAI
from datetime import datetime
import json
from typing import Dict, List

app = FastAPI(title="Indian Airlines Conversational IVR")

# Your Twilio number
TWILIO_NUMBER = "+19789694592"

# Initialize OpenAI
client = OpenAI(api_key=os.getenv("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", ""))

# In-memory session storage (use Redis in production)
sessions: Dict[str, dict] = {}

# System prompt for AI assistant
SYSTEM_PROMPT = """You are a helpful Indian Airlines voice assistant. Keep responses under 30 words for voice interaction.

Your capabilities:
1. Book flights (collect: destination, date, passenger name)
2. Check booking status (collect: booking ID)
3. Cancel bookings (collect: booking ID)

Extract information from user's natural speech. If information is missing, ask for it.

Respond in JSON format:
{
    "intent": "book_flight|check_booking|cancel_booking|greeting|unknown",
    "message": "what to say to the user",
    "collected_info": {
        "destination": "city if mentioned",
        "date": "date if mentioned",
        "booking_id": "ID if mentioned",
        "passenger_name": "name if mentioned"
    },
    "info_complete": true/false,
    "next_step": "ask_destination|ask_date|ask_name|ask_booking_id|complete|clarify"
}

Be conversational and natural. Handle Indian city names correctly.
"""

def get_ai_response(user_input: str, conversation_history: List[dict]) -> dict:
    """
    Process user input through OpenAI to get intelligent response
    
    Args:
        user_input: What user said
        conversation_history: Previous conversation messages
        
    Returns:
        AI response with intent, message, and extracted entities
    """
    if not client.api_key:
        # Fallback if OpenAI not configured
        return fallback_response(user_input)
    
    try:
        # Build conversation for GPT
        messages = [{"role": "system", "content": SYSTEM_PROMPT}]
        messages.extend(conversation_history)
        messages.append({"role": "user", "content": user_input})
        
        # Call OpenAI
        response = client.chat.completions.create(
            model="gpt-4",
            messages=messages,
            temperature=0.7,
            max_tokens=150
        )
        
        ai_message = response.choices[0].message.content
        
        # Parse JSON response
        try:
            return json.loads(ai_message)
        except json.JSONDecodeError:
            # If not JSON, create simple structure
            return {
                "intent": "unknown",
                "message": ai_message,
                "collected_info": {},
                "info_complete": False,
                "next_step": "clarify"
            }
            
    except Exception as e:
        print(f"OpenAI Error: {e}")
        return fallback_response(user_input)

def fallback_response(user_input: str) -> dict:
    """Simple keyword-based fallback if OpenAI unavailable"""
    text = user_input.lower()
    
    if any(word in text for word in ["book", "booking", "reserve", "flight"]):
        return {
            "intent": "book_flight",
            "message": "I can help you book a flight. Where would you like to fly to?",
            "collected_info": {},
            "info_complete": False,
            "next_step": "ask_destination"
        }
    elif any(word in text for word in ["check", "status", "lookup"]):
        return {
            "intent": "check_booking",
            "message": "I can check your booking. What's your booking ID?",
            "collected_info": {},
            "info_complete": False,
            "next_step": "ask_booking_id"
        }
    elif any(word in text for word in ["cancel", "delete"]):
        return {
            "intent": "cancel_booking",
            "message": "I can help cancel your booking. What's your booking ID?",
            "collected_info": {},
            "info_complete": False,
            "next_step": "ask_booking_id"
        }
    else:
        return {
            "intent": "unknown",
            "message": "I can help you book a flight, check your booking, or cancel a reservation. What would you like?",
            "collected_info": {},
            "info_complete": False,
            "next_step": "clarify"
        }

def create_session(call_sid: str) -> dict:
    """Create new call session"""
    session = {
        "session_id": str(uuid.uuid4()),
        "call_sid": call_sid,
        "conversation_history": [],
        "intent": None,
        "collected_info": {},
        "created_at": datetime.now().isoformat()
    }
    sessions[call_sid] = session
    return session

def get_session(call_sid: str) -> dict:
    """Get or create session"""
    return sessions.get(call_sid) or create_session(call_sid)

def complete_booking(session: dict) -> str:
    """Complete flight booking with collected information"""
    info = session["collected_info"]
    booking_id = f"AI{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    # Here you would save to database
    message = (
        f"Perfect! Your flight to {info.get('destination', 'your destination')} "
        f"on {info.get('date', 'your selected date')} has been booked. "
        f"Your booking ID is {booking_id}. "
        f"A confirmation will be sent to your phone. "
        f"Thank you for choosing Indian Airlines!"
    )
    return message

def check_booking_status(booking_id: str) -> str:
    """Check booking status (mock - replace with real database)"""
    # Mock response
    return (
        f"Your booking {booking_id} is confirmed and on schedule. "
        f"Flight departs as planned. Have a great journey!"
    )

def cancel_booking_process(booking_id: str) -> str:
    """Cancel booking (mock - replace with real database)"""
    return (
        f"Your booking {booking_id} has been successfully cancelled. "
        f"Refund will be processed within 5-7 business days. "
        f"We hope to serve you again soon."
    )

# ============================================
# Twilio Webhook Endpoints
# ============================================

@app.get("/")
def home():
    """Home endpoint with service info"""
    return {
        "status": "ok",
        "service": "Indian Airlines Conversational IVR",
        "twilio_number": TWILIO_NUMBER,
        "features": [
            "Natural Language Understanding",
            "Context-aware conversations",
            "Multi-turn dialogue",
            "Real-time speech processing"
        ],
        "ai_configured": bool(client.api_key),
        "active_sessions": len(sessions)
    }

@app.get("/health")
def health():
    """Health check for monitoring"""
    return {
        "status": "healthy",
        "timestamp": datetime.now().isoformat(),
        "openai_configured": bool(client.api_key),
        "twilio_number": TWILIO_NUMBER,
        "active_calls": len(sessions)
    }

@app.post("/twilio/voice")
async def twilio_voice_entry(request: Request):
    """
    Main entry point when call comes to your Twilio number
    This is what you configure in Twilio Console as webhook URL
    """
    data = await request.form()
    call_sid = data.get("CallSid")
    from_number = data.get("From")
    
    print(f"üìû Incoming call: {call_sid} from {from_number}")
    
    # Create session for this call
    create_session(call_sid)
    
    # Create TwiML response
    response = VoiceResponse()
    
    # Welcome message
    response.say(
        "Welcome to Indian Airlines! I'm your AI assistant. "
        "How may I help you today?",
        voice="Polly.Aditi",  # Indian English voice
        language="en-IN"
    )
    
    # Gather user's speech input
    gather = Gather(
        input="speech",
        action="/twilio/process",
        method="POST",
        speechTimeout="auto",
        language="en-IN",
        enhanced=True  # Better speech recognition
    )
    
    gather.say(
        "You can say things like: book a flight, check my booking, or cancel my reservation.",
        voice="Polly.Aditi",
        language="en-IN"
    )
    
    response.append(gather)
    
    # If no input
    response.say(
        "I didn't hear anything. Please call back when you're ready. Goodbye!",
        voice="Polly.Aditi",
        language="en-IN"
    )
    response.hangup()
    
    return Response(content=str(response), media_type="application/xml")

@app.post("/twilio/process")
async def twilio_process_speech(request: Request):
    """
    Process user's speech input through AI
    This is where the conversational magic happens
    """
    data = await request.form()
    call_sid = data.get("CallSid")
    speech_result = data.get("SpeechResult", "").strip()
    
    print(f"üé§ User said: {speech_result}")
    
    # Get session
    session = get_session(call_sid)
    
    response = VoiceResponse()
    
    # Handle empty input
    if not speech_result:
        response.say(
            "I didn't catch that. Could you please repeat?",
            voice="Polly.Aditi",
            language="en-IN"
        )
        gather = Gather(
            input="speech",
            action="/twilio/process",
            method="POST",
            speechTimeout="auto",
            language="en-IN"
        )
        response.append(gather)
        return Response(content=str(response), media_type="application/xml")
    
    # Add to conversation history
    session["conversation_history"].append({
        "role": "user",
        "content": speech_result
    })
    
    # Get AI response
    ai_result = get_ai_response(speech_result, session["conversation_history"])
    
    print(f"ü§ñ AI Response: {ai_result}")
    
    # Add AI response to history
    session["conversation_history"].append({
        "role": "assistant",
        "content": ai_result["message"]
    })
    
    # Update session with extracted info
    session["intent"] = ai_result["intent"]
    session["collected_info"].update(ai_result.get("collected_info", {}))
    
    # Check if we have all information needed
    if ai_result.get("info_complete"):
        # Complete the transaction
        if ai_result["intent"] == "book_flight":
            final_message = complete_booking(session)
            response.say(final_message, voice="Polly.Aditi", language="en-IN")
            response.hangup()
            
        elif ai_result["intent"] == "check_booking":
            booking_id = session["collected_info"].get("booking_id")
            final_message = check_booking_status(booking_id)
            response.say(final_message, voice="Polly.Aditi", language="en-IN")
            response.hangup()
            
        elif ai_result["intent"] == "cancel_booking":
            booking_id = session["collected_info"].get("booking_id")
            final_message = cancel_booking_process(booking_id)
            response.say(final_message, voice="Polly.Aditi", language="en-IN")
            response.hangup()
    else:
        # Continue conversation - need more info
        response.say(ai_result["message"], voice="Polly.Aditi", language="en-IN")
        
        # Gather next input
        gather = Gather(
            input="speech",
            action="/twilio/process",
            method="POST",
            speechTimeout="auto",
            language="en-IN",
            enhanced=True
        )
        response.append(gather)
        
        # Timeout handling
        response.say(
            "I didn't hear you. Let me transfer you to an agent.",
            voice="Polly.Aditi",
            language="en-IN"
        )
        response.hangup()
    
    return Response(content=str(response), media_type="application/xml")

@app.post("/twilio/status")
async def twilio_status_callback(request: Request):
    """
    Handle call status updates from Twilio
    Configure this as Status Callback URL in Twilio Console
    """
    data = await request.form()
    call_sid = data.get("CallSid")
    call_status = data.get("CallStatus")
    
    print(f"üìä Call {call_sid}: {call_status}")
    
    # Clean up session when call ends
    if call_status in ["completed", "failed", "busy", "no-answer"]:
        if call_sid in sessions:
            print(f"üóëÔ∏è Cleaning up session: {call_sid}")
            del sessions[call_sid]
    
    return {"status": "ok"}

# ============================================
# Debugging & Monitoring Endpoints
# ============================================

@app.get("/sessions")
def list_sessions():
    """List all active sessions (for debugging)"""
    return {
        "active_sessions": len(sessions),
        "sessions": [
            {
                "call_sid": call_sid,
                "intent": s.get("intent"),
                "collected_info": s.get("collected_info"),
                "turns": len(s.get("conversation_history", [])) // 2,
                "created_at": s.get("created_at")
            }
            for call_sid, s in sessions.items()
        ]
    }

@app.get("/session/{call_sid}")
def get_session_detail(call_sid: str):
    """Get detailed session info"""
    if call_sid not in sessions:
        return {"error": "Session not found"}
    return sessions[call_sid]

@app.delete("/session/{call_sid}")
def delete_session_manual(call_sid: str):
    """Manually delete a session"""
    if call_sid in sessions:
        del sessions[call_sid]
        return {"status": "deleted"}
    return {"error": "Session not found"}

@app.get("/test-ai")
def test_ai():
    """Test if OpenAI is configured and working"""
    if not client.api_key:
        return {
            "status": "error",
            "message": "OpenAI API key not configured",
            "solution": "Add OPENAI_API_KEY to your .env file"
        }
    
    try:
        # Test API call
        test_response = client.chat.completions.create(
            model="gpt-4",
            messages=[{"role": "user", "content": "Say 'API working'"}],
            max_tokens=10
        )
        return {
            "status": "ok",
            "message": "OpenAI API is working!",
            "response": test_response.choices[0].message.content
        }
    except Exception as e:
        return {
            "status": "error",
            "message": str(e)
        }

# ============================================
# Run Instructions
# ============================================

if __name__ == "__main__":
    import uvicorn
    print("üöÄ Starting Indian Airlines Conversational IVR")
    print(f"üìû Twilio Number: {TWILIO_NUMBER}")
    print(f"ü§ñ OpenAI Configured: {bool(client.api_key)}")
    uvicorn.run(app, host="0.0.0.0", port=8000)
